# Js- 生命週期(垃圾回收)
###### tags: `JavaScript` `重新認識JaveScript`
- 記憶體的生命週期
    - 內存分配 : 當宣告對象時，自動分配記憶體
        ```
            const a  = 18
        ```
    - 內存使用 : 使用變數 & func
        ```
            const obj = {
                age : 19,
            }
        ```
    - 內存回收 : 使用完畢會被自動回收
        ```
            function fn(){
                const age = 18
                console.log(age)
            }
        ```
    - 例外
        - 全域變數不會被自動回收(當關閉頁面才會被回收)
        - 一般狀況下局部變量在不使用的情況下會被回收
    - 內存洩漏
        - 分配的記憶體由於某種原因無法 / 未釋放的情況
- 回收機制 - 演算法說明
    - 資料結構
        - stack(棧)
            - 由**操作系統自動分配釋放**的func參數、局部變數...等，基本的資料型別會被放到這邊。
        - heap(堆)
            - 由**工程師**分配釋放，若是工程師不釋放會被**垃圾回收機制**回收，**複雜的資料類型**會被放到這邊。
    - 演算法
        - 引用計數(ie8)
            - 流程
                1. 跟蹤被引用的次數
                2. 如果被引用一次，紀錄+1
                3. 如果減少一個引用就-1
                4. 如果引用為0 就釋放記憶體
            - 過程
                1. 一組Array為複雜資料型態 => 放進heap中
                2. 將這組Array的地址放進stack之中
                ```
                    let person = {
                        age : 18,
                        name: 'pagge'
                    }
                    let p = person
                    person = 1 //person指向目標從obj轉為 1 
                    p = null // p的目標從 per這個obj轉為 null
                    所以此時person這個obj沒有被引用 == 引用次數為0，就被系統回收                    ```
            - 問題
                - 當存在相互引用時，會無法回收內存
                    - 當相互引用時，計數器不為0。
        - 標記清除法
            - 差異
                - 將不再使用的對象定義更改為**無法達到的對象**
                - 從根部(JS中為全域對象)，定期掃描只要能從全局開始能找到的目標，就判定為還需要的資料，所以不會被回收。
                - 找不到的對象，會被**標記為不使用**，會被回收。
                - 解決相互引用的問題
            - 結論
                - 從根部開始能找到的留著，找不到的會被回收。