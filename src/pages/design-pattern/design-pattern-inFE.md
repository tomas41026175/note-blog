# 設計模式在前端中的應用
### 常見的模式
1. 觀察者模式 (Observer Pattern)：當一個資料發生變化時，能夠通知其他元件進行相應的更新。舉例來說，當一個使用者在網站上進行某個操作時，可能會需要將這個操作結果同步到其他使用者的介面上，此時就可以使用觀察者模式來實現。

2. 建造者模式 (Builder Pattern)：用於創建複雜的物件，將創建過程分離出來，使得創建過程與使用過程分離，同時也可以讓不同的建造者實現不同的創建過程。舉例來說，當需要創建一個複雜的 UI 元件時，可能需要創建多個子元件並將它們組合起來，此時可以使用建造者模式來簡化創建過程。

3. 裝飾者模式 (Decorator Pattern)：用於在不改變原有物件的前提下，為物件添加額外的功能。舉例來說，當需要為一個元件添加動畫效果時，可以使用裝飾者模式來實現，將動畫效果封裝成一個裝飾者，再將裝飾者添加到元件中。

4. 策略模式 (Strategy Pattern)：用於將算法的實現與使用分離開來，讓使用者能夠根據需要選擇不同的算法。舉例來說，當需要對一個列表進行排序時，可以使用策略模式將排序算法封裝成策略，讓使用者能夠根據需要選擇不同的排序算法。

5. 職責鏈模式 (Chain of Responsibility Pattern)：用於將請求的處理分離開來，讓多個物件能夠按照順序處理請求，直到有一個物件能夠處理為止。舉例來說，當需要對一個輸入框進行驗證時，可以使用職責鏈模式將多個驗證器封裝成職責鏈，讓驗證器能夠按照順序進行驗證，直到有一個驗證器能夠通過為止。

### Example
- 以下是一個使用**觀察者模式**的簡單範例，假設我們要實現一個按鈕，當按下該按鈕時，會彈出一個提示框：
    ```
        // 定義按鈕類別
        class Button {
          constructor() {
            this.clickHandlers = [];
          }

          // 添加點擊事件處理函數
          addClickHandler(handler) {
            this.clickHandlers.push(handler);
          }

          // 觸發點擊事件
          click() {
            this.clickHandlers.forEach(handler => handler());
          }
        }

        // 創建按鈕實例
        const button = new Button();

        // 添加點擊事件處理函數
        button.addClickHandler(() => {
          alert('按鈕被點擊了！');
        });

        // 觸發點擊事件
        button.click();
    ```
- 在上述範例中，Button類別充當被觀察者，clickHandlers陣列充當觀察者列表，addClickHandler方法用來向clickHandlers陣列中添加觀察者（事件處理函數），click方法用來觸發點擊事件並通知觀察者。當按鈕被點擊時，click方法會遍歷clickHandlers陣列，依次調用所有觀察者的處理函數，從而彈出提示框。

- 這個範例中，觀察者模式提供了一個靈活的方式來處理按鈕點擊事件，使得不同的事件處理函數可以獨立定義並在需要時添加或刪除，實現了代碼的可維護性和可擴展性。