# 設計模式(design pattern)
### 創建型設計模式
#### 創建型設計模式主要是用於將對象的創建與使用分離，使得系統更加靈活。常見的創建型設計模式包括：
- 單例模式：確保類只有一個實例，並提供一個全局訪問點。
- 工廠模式：將對象的創建延遲到子類中實現，從而實現系統的解耦。
- 抽象工廠模式：提供一個創建一個相關對象族的介面，而無需指定具體類。
- 建造者模式：將一個複雜對象的構建與其表示分離，使得同樣的構建過程可以創建不同的表示。

### 結構型設計模式
#### 結構型設計模式主要是用於處理類或對象的組合，以形成更大的結構。常見的結構型設計模式包括：
- 適配器模式：將一個類的接口轉換成客戶希望的另一個接口，從而適配不兼容的接口。
- 裝飾者模式：動態地為對象添加功能，同時不改變其結構。
- 代理模式：通過代理對象來控制對原始對象的訪問，從而實現對象的保護和增強。
- 外觀模式：提供一個統一的接口，用來訪問子系統中的一群接口，從而簡化子系統的使用。

### 行為型模式（Behavioral Pattern）
#### 是指著重在物件間的溝通和職責分配的模式，用於描述物件或類之間如何互相溝通和協作，以完成特定任務或實現特定的功能。常見的行為型模式包括：

- 觀察者模式（Observer Pattern）：定義了對象之間的一對多依賴關係，當一個對象的狀態發生改變時，其相關的所有對象都會收到通知並自動更新。
- 迭代器模式（Iterator Pattern）：提供了一種方法來訪問一個容器物件中各個元素，而不需要暴露該容器的內部細節。
- 策略模式（Strategy Pattern）：定義了一系列的算法，把它們一個個封裝起來，並且使它們可以互相替換。策略模式使得算法可以獨立於使用它的客戶端而變化。
- 職責鏈模式（Chain of Responsibility Pattern）：將多個對象連成一條鏈，並依次試圖處理某一請求，如果某一對象可以處理該請求，則直接處理；否則將請求傳遞給下一個對象，直到所有的對象都無法處理為止。
- 命令模式（Command Pattern）：將一個請求對象和接收該請求的對象解耦，將請求對象封裝成一個命令，並且將其可以動態地設定和替換。命令模式可以使得請求發送者和接收者之間的耦合度大大降低。
- 狀態模式（State Pattern）：允許一個對象在其內部狀態發生改變時改變其行為，從而使得該對象看起來像是改變了其類別。
- 訪問者模式（Visitor Pattern）：將對象的操作從對象本身分離出來，放在其它的對象中，使其能夠在不改變各個對象的前提下，定義作用於這些對象上的新操作。
- 等待模式（Wait Pattern）：用於解決多線程之間的同步和通信