# React & Vue 中的虛擬DOM差異比較
## 虛擬DOM
- 為了減少真實DOM的操作次數，從而提高應用程式的性能。

---
### React
- 於React Element構成樹狀結構，使用Reconciliation(調和)算法實現比較新舊虛擬DOM的差異，減少DOM操作的次數。
    - 調和演算法 : 
        - 流程
        	1. 如果節點類型不同，則直接刪除舊節點，並插入新節點。
        	2. 如果節點類型相同，則比較他們的屬性&子節點。
        	    - 屬性不同，直接更新屬性
        	    - 子節點不同，進行遞歸比較，找出差異之處，只更新不同之處。
        	        - 遞歸的過程中會生成一個差異對象(差異陣列)，用於描述新舊虛擬DOM之間的差異。 然後React會使用這個差異對象，對真實DOM進行最小化更新，從而提高應用程式的性能。
        	3. 對於新增的節點，直接插入到DOM樹中。
        	4. 對於刪除的節點，直接從DOM樹中刪除。
        - 核心邏輯
            - 用於比較新舊虛擬DOM樹之間的差異，並且只更新差異的部分。
---
### Vue
- 使用**觀察者模式**監聽數據的變化，一旦發生變化，Vue就會重新渲染虛擬節點進行比較，找出差異之處，最後只更新不同的部分，達到減少操作真實DOM的目的。
    - 觀察者模式 : Observer Pattern
        - 用於在對象之間建立一對多的依賴關係，當一個對象的狀態發生改變時，所有依賴它的對象都會得到通知並自動更新。
        - 在Vue中，數據模型是可觀察的(Observable)，也就是說當數據模型中的數據發生變化時，Vue會自動檢測並通知相關的畫面進行更新。
    - 優點
        - 可以實現對象之間的解耦，model和view之間不存在直接的依賴關係。 當數據模型發生變化時，Vue會自動通知畫面進行更新，從而實現雙向綁定。
    - 缺點
        - 過多的監聽器 & 計算屬性可能導致性能問題，由於當數據發生變化Vue會通知所有依賴於這個數據的畫面進行更新，所以當數據 / 畫面的數量過多時，可能會對性能有負面影響。
        - 對象內部的監聽器可以能會導致內存洩漏(無法被JS的垃圾回收機制自動回收)
            - Vue使用Object.defineProperty實踐對象的監聽，但如果對象在多個地方被引用，並且這些引用沒有被適當的清理，可以會被長期保存在內存中，從而導致內存洩漏。
        - 對象內部的監聽器可能會導致封裝性被破壞，Vue監聽器需要將對向的屬性暴露出來，從而實現對屬性的監聽，這樣會導致對象的內部屬性暴露出來，從而破壞封裝性。
    - 結論
        - 使用觀察者模式實現數據的雙向綁定十分優秀，但也存在一些性能 & 封裝性的缺陷。
---
### 結論
- React使用